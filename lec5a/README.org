#+TITLE: 6.178 Lecture 5: More on Objects
#+AUTHOR: Aaron Zeng
#+EMAIL: a2z@mit.edu
#+DATE: [2017-01-20 Fri 11:00-13:00]
#+OPTIONS: ':t num:nil toc:nil reveal_history:t
#+REVEAL_ROOT: ./node_modules/reveal.js
#+REVEAL_HLEVEL: 2
#+REVEAL_TRANS: slide
#+REVEAL_THEME: solarized
#+REVEAL_PLUGINS: (highlight notes)
#+REVEAL_EXTRA_CSS: ./style.css
* Announcements
** Problem Set 1
Problem Set 1 staff solutions have been made available at
[[https://github.mit.edu/6178-2017/ps1-staff-solutions][6178-2017/ps1-staff-solutions]]. Click on the commit message or the commit SHA to
see the solution code itself.

#+BEGIN_NOTES
  Demo this.
#+END_NOTES
** Lecture repos
 Make sure to make your personal lecture repos private. Select "Private" when
 you're creating the repository so that only you can see your lecture exercises.
* Inheritance
** Terminology
- Classes in Java are arranged in a *class hierarchy*, which can be imagined as
  a tree of classes
- Each parent-child edge represents the relationship between a class and its
  *subclass*.
- The parent class of a subclass is called its *superclass*.
- The subclass is said to *inherit* from its superclass.
** Single Inheritance Multiple Implementation
A class can have multiple subclasses, but each class may only have *one* parent
class from which it inherits. This is known as *single inheritance*, as opposed
to *multiple inheritance*, which is the system used in some other technologies
like C++, Perl, and the Common Lisp Object System.
** Basic Inheritance
Instances of a subclass include the state and behavior of the subclass, as well
as its parent class (and so on up the hierarchy). That is to say, if we have
class ~Animal~ with subclass ~Dog~, every ~Dog~ instance will /inherit/ the
properties and methods of the ~Animal~ class.
*** Example
#+INCLUDE: "src/examples/Example1.java" src java
*** Access Modifiers
- Fields and methods of the superclass will be /inherited/, but if they are
  ~private~ or have no access modifier, they will not be "visible" in the
  subclass.
#+BEGIN_NOTES
  Internally the object will still include those fields and methods, allowing it
  to still act like an instance of the superclass.
#+END_NOTES
- If the fields are visible to the subclass, e.g., ~protected~ or ~public~, then
  they can be accessed within the subclass as normal.
*** Exercise
#+INCLUDE: "src/exercises/BasicInheritance.java" src java
** Subtyping
An instance of a subclass can be treated, for all intents and purposes, as an
instance of the superclass. For example, all ~Dog~ objects can be simply treated
as ~Animal~ objects.

We can call ~Dog~ a *subtype* of ~Animal~. Since a *type* just specifies a set
of possible values, and all possible ~Dog~ values are ~Animal~ values too, we
can say that the set of values specified by ~Dog~ is a subset of that specified
by ~Animal~.
*** Example
#+INCLUDE: "src/examples/Example2.java" src java

We can also put multiple different kinds of ~Animal~ into the same array, by
declaring the array type to be ~Animal[]~.

#+REVEAL: split

In the previous example, we cannot treat ~myDog~ as a ~Dog~ instance even though
it is! This is because we have declared the type of the variable ~myDog~ to be
~Animal~, so the Java compiler requires us to treat ~myDog~ as only an ~Animal~.
*** Casting
We can get around this restriction in the following way:

#+BEGIN_SRC java
  Dog iSwearItsADog = (Dog) myDog;
  iSwearItsADog.bark();
#+END_SRC

By forcibly *casting* the value of ~myDog~ to type ~Dog~, we make the compiler
treat the expression as an instance of ~Dog~ instead of as an ~Animal~, so then
we can call ~.bark()~ on the resulting expression.

#+REVEAL: split

If we tried to cast an ~Animal~ that wasn't actually an instance of ~Dog~ to
type ~Dog~, then when we run the program, Java will encounter that line,
detect that ~myDog~ mysteriously had type, say, ~Cat~ instead of ~Dog~, and
would throw a ~ClassCastException~, basically telling you that you can't do
that.
** Overriding
You can override the behavior of a superclass method in the subclass by simply
defining a method with the same name and signature:

#+INCLUDE: "src/examples/Example3.java" src java

Note that the correct ~color()~ method is called for the ~Carrot~ object even
though the variable that refers to it has a declared type of ~Vegetable~!
*** ~@Override~
You can annotate overridden methods with an ~@Override~ tag. This tag is
optional but recommended because it will help catch typos (learn more in 6.031).
** ~super~
You can access the original implementation of overridden methods using the
~super~ keyword. This allows you to override a method by just *slightly*
altering the original behavior.
*** Ordinary methods
#+INCLUDE: "src/examples/Example4.java" src java
*** Constructors
#+INCLUDE: "src/examples/Example1.java" src java
*** Exercise
#+INCLUDE: "src/exercises/OverrideAndSuper.java" src java
** ~Object~ class
All classes in Java are part of the same hierarchy, and the root of the
hierarchy is class ~Object~. Every class is a subclass of ~Object~ (perhaps
through several layers), and every object is therefore an instance of ~Object~.

~Object~ has several methods, but the most useful one is ~toString()~.
*** ~toString()~
~Object.toString()~ returns a "human-readable" string representation of the
object. For objects whose class does not override ~toString()~, the value
returned by ~toString()~ includes the name of the class of the instance as well
as a unique(-ish) hexadecimal ID for that object.
*** Overriding ~toString()~
#+INCLUDE: "src/examples/Example5.java" src java
* Interfaces
Say you have a class ~WaterBottle~ and a class ~MetalObject~. ~WaterBottle~ has
a bunch of useful methods for objects that contain water, such as pouring out
the water into a drinking cup, emptying the water, asking how much water is left
in the vessel, etc. ~MetalObject~ has a bunch of useful methods for objects made
out of metal, e.g., ~recycle()~.

What if you have a ~MetalWaterBottle~ in your system, which you would like to
treat sometimes as a ~WaterBottle~ and sometimes as a ~MetalObject~?

#+REVEAL: split

You cannot make ~MetalWaterBottle~ inherit from both ~WaterBottle~ and
~MetalObject~, because Java prohibits multiple inheritance.

#+BEGIN_EXAMPLE
  #-------------#    #-------------#
  | WaterBottle |    | MetalObject |
  #-------------#    #-------------#
             ^           ^
             |           |
         #------------------#
         | MetalWaterBottle |
         #------------------#




#+END_EXAMPLE

#+BEGIN_EXAMPLE
        ...                                                           .          ..                  s       .                                       ..      .
     xH88"`~ .x8X                                                    @88>  x .d88"                  :8      @88>                                  x88f` `..x88. .>
   :8888   .f"8888Hf        u.      ..    .     :     .d``           %8P    5888R                  .88      %8P          u.      u.    u.       :8888   xf`*8888%     .u    .      .u    .          u.      .u    .
  :8888>  X8L  ^""`   ...ue888b   .888: x888  x888.   @8Ne.   .u      .     '888R         u       :888ooo    .     ...ue888b   x@88k u@88c.    :8888f .888  `"`     .d88B :@8c   .d88B :@8c   ...ue888b   .d88B :@8c
  X8888  X888h        888R Y888r ~`8888~'888X`?888f`  %8888:u@88N   .@88u    888R      us888u.  -*8888888  .@88u   888R Y888r ^"8888""8888"    88888' X8888. >"8x  ="8888f8888r ="8888f8888r  888R Y888r ="8888f8888r
  88888  !88888.      888R I888>   X888  888X '888>    `888I  888. ''888E`   888R   .@88 "8888"   8888    ''888E`  888R I888>   8888  888R     88888  ?88888< 888>   4888>'88"    4888>'88"   888R I888>   4888>'88"
  88888   %88888      888R I888>   X888  888X '888>     888I  888I   888E    888R   9888  9888    8888      888E   888R I888>   8888  888R     88888   "88888 "8%    4888> '      4888> '     888R I888>   4888> '
  88888 '> `8888>     888R I888>   X888  888X '888>     888I  888I   888E    888R   9888  9888    8888      888E   888R I888>   8888  888R     88888 '  `8888>       4888>        4888>       888R I888>   4888>
  `8888L %  ?888   ! u8888cJ888    X888  888X '888>   uW888L  888'   888E    888R   9888  9888   .8888Lu=   888E  u8888cJ888    8888  888R     `8888> %  X88!       .d888L .+    .d888L .+   u8888cJ888   .d888L .+
   `8888  `-*""   /   "*888*P"    "*88%""*88" '888!` '*88888Nu88P    888&   .888B . 9888  9888   ^%888*     888&   "*888*P"    "*88*" 8888"     `888X  `~""`   :    ^"8888*"     ^"8888*"     "*888*P"    ^"8888*"
     "888.      :"      'Y"         `~    "    `"`   ~ '88888F`      R888"  ^*888%  "888*""888"    'Y"      R888"    'Y"         ""   'Y"         "88k.      .~        "Y"          "Y"         'Y"          "Y"
       `""***~"`                                        888 ^         ""      "%     ^Y"   ^Y'               ""                                     `""*==~~`
                                                        ,*8E
                                                        '8>
                                                         "

#+END_EXAMPLE
** What are interfaces, abstractly?
An *interface* defines a set of classes with shared behavior. Instances of these
classes can then be treated the same with respect to that behavior, without
knowledge of the concrete class of those instances.
** What are interfaces, concretely?
An ~interface~ defines a set of methods (names and signatures). Classes that
have all of the methods in an interface are said to *implement* that interface.

Interfaces can also be treated as a type. Classes that *implement* the interface
are then subtypes of the interface, because their instances have all of the
behavior specified by the interface (and then some).
** Interface example
#+INCLUDE: "src/examples/Example6.java" src java
** Exercise
#+INCLUDE: "src/exercises/Interface.java" src java
** Coming full circle
Now, we can define ~MetalObject~ as an interface with a ~recycle()~ method, and
~WaterBottle~ as an interface with an ~howMuchLeft()~ method, and so on.

~MetalWaterBottle~ can now implement both of these interfaces, and can be
treated as each of the different types in different contexts in your program.
* Important Standard Library Classes
All of these classes and interfaces are in ~java.util~.
** ~List~
~List~'s are like Python lists. They represent ordered sequences of elements
that can be accessed by 0-based numerical indices. Like Python's lists, they can
be appended to, or inserted into. This makes them strictly more flexible than
arrays because you can change the length of a ~List~ over the course of your
program's execution.

#+REVEAL: split

~List~ is actually an ~interface~. It has many methods that you might expect,
including ~get()~, ~set()~, ~size()~, ~add()~ (append), and so on. There are
several implementations of ~List~ in the Java standard library (i.e., classes
that "implement" ~List~), but the most important is ~ArrayList~.
*** ~ArrayList~
An ~ArrayList~ is a ~List~ whose internal data structure is an array. When you
run out of space and need to add more elements, it:

- Creates a new, bigger, array;
- Copies all of the elements from the old array; and
- Inserts the new element at the end
*** Example
#+BEGIN_SRC java
  List<String> favoriteWords = new ArrayList<String>();

  favoriteWords.add("teacup");
  favoriteWords.add("pasta");
  favoriteWords.add("java");

  System.out.println(favoriteWords); // [teacup, pasta, java]

  System.out.println(favoriteWords.size()); // 3

  System.out.println(favoriteWords.get(1)); // pasta

  favoriteWords.set(2, "Java");

  System.out.println(favoriteWords); // [teacup, pasta, Java]
#+END_SRC

#+BEGIN_NOTES
  Turns out org-reveal has a bug that causes the angle brackets in src
  environments to fail to be escaped. Guess who had to file an [[https://github.com/yjwen/org-reveal/issues/265][issue]] at 01:20
  a.m. this morning?
#+END_NOTES
*** Exercise
#+INCLUDE: "src/exercises/ListExercise.java" src java

#+BEGIN_NOTES
  Mention that ~println()~ has an implicit ~toString()~ call.
#+END_NOTES
** ~Map~
A ~Map<K, V>~ is akin to a Python dictionary. Conceptually, it is an unordered
table with key-value pairs, at most one per unique key.

#+BEGIN_NOTES
  K is the type of the key element, V is the type of the V element. For example,
  Map<String, Integer>
#+END_NOTES

*** "Key" operations
- ~get(key)~ retrieves the value associated with a given key in the map, null if
  no such key
- ~put(key, val)~ associates the given key with the value, replacing if already
  present
- ~size()~ returns the number of key-value pairs
- ~containsKey(key)~ returns ~true~ iff the map contains an entry for ~key~
*** ~HashMap~
~HashMap~ is the most commonly-used implementation of ~Map~.
*** Example
#+BEGIN_SRC java
  Map<String, Integer> phonebook = getTheDataSomehow();

  String name = "Jane Doe";
  int phoneNumber = phonebook.get(name);
  System.out.printf("%s can be reached at %d.\n", name, phoneNumber);
#+END_SRC
** ~Set~
A ~Set~ represents an unordered set of elements.
*** Important operations
- ~contains(e)~ returns ~true~ iff the set contains an element equal to ~e~
- ~add(e)~ adds element ~e~ to the set
- ~remove(e)~ removes element ~e~ from the set
- ~size()~ returns the number of elements in the set
*** ~HashSet~
~HashSet~ is the most commonly-used implementation of ~Set~.
*** Example
#+BEGIN_SRC java
  Set<Integer> luckyNumbers = openFortuneCookie();

  luckyNumbers.remove(13); // in case the fortune cookie is wrong

  int myFavoriteNumber = 8;

  boolean isLucky = luckyNumbers.contains(myFavoriteNumber);
#+END_SRC
** Iterators and Iterables
~Iterator<E>~ and ~Iterable<E>~ are both interfaces.

#+REVEAL: split

An ~Iterator<E>~ is an object that can supply objects of type ~E~. When you call
~next()~ on an ~Iterator~, it returns the next object of type ~E~ in the
iteration, or throws ~NoSuchElementException~ if there are no more elements.

#+REVEAL: split

You can call ~hasNext()~ on an ~Iterator<E>~ to find out if there are any more
elements available. This can help you avoid ~NoSuchElementException~ errors.

#+REVEAL: split

#+BEGIN_SRC java
  // this code prints out all of the names provided by namesIter

  Iterator<String> namesIter = magic();

  while (namesIter.hasNext()) {
      String name = namesIter.next();
      System.out.println(name);
  }
#+END_SRC

#+REVEAL: split

An ~Iterable<E>~ is an object that has a method ~iterator()~, which must return
a value of type ~Iterator<E>~. That is to say, it is an object that can be
"iterated over", such as ~List~'s, ~Set~'s, and even arrays.
*** "Enhanced" ~for~ loops
~Iterable~'s are useful because they enable a convenient syntax feature in Java:
the "enhanced" ~for~ loop. This makes iterating over things easier:

#+BEGIN_SRC java
  int[] numbers = new int[] { 1, 2, 3, 4, 5 };

  int sum = 0;
  for (int x : numbers) {
      sum += x;
  }

  System.out.println(sum); // 15
#+END_SRC

#+BEGIN_NOTES
  This can be a ~List~ or a ~Set~ too.
#+END_NOTES

#+REVEAL: split

An enhanced ~for~ loop has the following form:

#+BEGIN_SRC java
  for (<type> <name> : <iterable>) {
      // do something with the variable <name>
  }
#+END_SRC

This iterates over the iterable until it is depleted, just like the previous
~while~-loop example.

** Collections
~List~'s and ~Set~'s are both ~Collection~'s. They represent a group of objects
called /elements/. There are many useful methods that operate on all kinds of
~Collection~'s in general. All ~Collection<E>~'s are ~Iterable<E>~'s.
